---
title: "scdrake | 02 - Normalization and clustering"
author: "Jiri Novotny, Jan Kubovciak"
institute: "Laboratory of Genomics and Bioinformatics @ Institute of Molecular Genetics of the ASCR"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    number_sections: false
    theme: "flatly"
    self_contained: true
    code_download: true
    df_print: "paged"
params:
  css_file: !expr here::here("Rmd/common/stylesheet.css")
  drake_cache_dir: !expr here::here(".drake")
date: "`r glue::glue('Document generated: {Sys.Date()}')`"
css: "`r params$css_file`"
---

```{r, include = FALSE, message = FALSE, warning = FALSE}
suppressPackageStartupMessages(library(magrittr))
if (rlang::is_true(getOption("knitr.in.progress"))) {
  params_ <- scdrake::scdrake_list(params)
}
drake_cache_dir <- params_$drake_cache_dir

drake::loadd(
  config_main, config_norm_clustering, doublet_score,
  cluster_kmeans_kc_tables, cluster_sc3_tables, cluster_sc3_stability_plots,
  dimred_plots_clustering_files, dimred_plots_clustering_files_out,
  dimred_plots_other_vars_files, dimred_plots_other_vars_files_out,
  selected_markers_plots, selected_markers_plots_files,
  cell_annotation_diagnostic_plots, cell_annotation_diagnostic_plots_files,
  path = drake_cache_dir
)

cfg <- config_norm_clustering

sce <- drake::readd(sce_final_norm_clustering, path = drake_cache_dir)
sce_metadata <- S4Vectors::metadata(sce)
sce_colData <- SingleCellExperiment::colData(sce)
sce_rowData <- SingleCellExperiment::rowData(sce)
cc_genes_valid <- all(!is.na(sce_colData$phase))
normalization_type_sce <- sce_metadata$normalization_type
hvg_metric <- sce_metadata$hvg_metric
hvg_selection <- sce_metadata$hvg_selection
hvg_selection_value <- sce_metadata$hvg_selection_value

if (!rlang::is_null(selected_markers_plots)) {
  selected_markers_plots_final <- dplyr::bind_cols(selected_markers_plots, selected_markers_plots_files = selected_markers_plots_files)
} else {
  selected_markers_plots_final <- NULL
}

## -- Variables for dimred_plots.Rmd child.
dp_dimred_names <- cfg$NORM_CLUSTERING_REPORT_DIMRED_NAMES
dp_clustering_names <- cfg$NORM_CLUSTERING_REPORT_CLUSTERING_NAMES
dp_selected_markers <- selected_markers_plots_final
dp_selected_markers_files_rel_start <- fs::path_dir(cfg$NORM_CLUSTERING_REPORT_HTML_FILE)
dp_dimred_plots_files_rel_start <- fs::path_dir(cfg$NORM_CLUSTERING_REPORT_HTML_FILE)
dp_cell_annotation_diagnostic_plots_rel_start <- fs::path_dir(cfg$NORM_CLUSTERING_REPORT_HTML_FILE)
```

***

```{r, child = here::here("Rmd/common/_header.Rmd")}
```

***

# Input data overview

Just to review data from the preceding pipeline step (`01 - quality control`):

```{r}
cat(drake::readd(sce_final_input_qc_info, path = drake_cache_dir)$str)
```

***

# Cell cycle phase assignment

Assign each cell a score, based on its expression of G2/M and S phase markers.
These marker sets should be anticorrelated in their expression levels, and cells expressing neither are likely not cycling and in G1 phase.

```{r, results = "asis"}
if (!cc_genes_valid) {
  scdrake::catn("**Cell cycle score and phases could not be computed for your dataset.** It is possible that it doesn't have any expressed cell-cycle genes.")
}
```

`r scdrake::format_used_functions(c("Seurat::cc.genes.updated.2019", "Seurat::CellCycleScoring()"))`

# Normalization

Normalization method: "`r normalization_type_sce`"

```{r, results = "asis"}
if (cfg$NORMALIZATION_TYPE == "none") {
  cat("(Normalization was performed in a previous pipeline run.)\n\n")
}

if (normalization_type_sce == "scran") {
  cat("**`scran`: normalization by deconvolution**\n\n")
  cat(
    "Cell-specific biases are normalized using the `scran::computeSumFactors()` method,",
    "which implements the deconvolution strategy for scaling normalization (*A. T. Lun, Bach, and Marioni 2016*).",
    "This computes size factors that are used to scale the counts in each cell.",
    "The assumption is that most genes are not differentially expressed (DE) between cells,",
    "such that any differences in expression across the majority of genes represents some technical bias that should be removed."
  )
  used_functions <- c("scran::computeSumFactors()", "scuttle::logNormCounts()")
  if (cfg$SCRAN_USE_QUICKCLUSTER) {
    used_functions <- c("scran::quickCluster()", used_functions)
  }
  scdrake::format_used_functions(used_functions, do_cat = TRUE)
} else if (normalization_type_sce == "sctransform") {
  cat("**`sctransform`: regularized negative binomial regression to normalize UMI count data.**\n\n")
  scdrake::format_used_functions("Seurat::SCTransform()", do_cat = TRUE)
}
```

# Highly variable genes (HVGs) selection

```{r, results = "asis"}
scdrake::catg0('**HVG metric: "{hvg_metric}"**\n\n')

if (hvg_metric == "gene_var") {
  var_field <- "bio"

  cat(
    "`scran::modelGeneVar()` models the variance of the log-expression profiles for each gene,",
    "decomposing it into technical and biological components based on a fitted mean-variance trend.\n\n"
  )

  scdrake::plot_hvg_fit(sce, "var")
  scdrake::format_used_functions("scran::modelGeneVar()", do_cat = TRUE)
} else if (hvg_metric == "gene_cv2") {
  var_field <- "ratio"

  cat(
    "`scran::modelGeneCV2()` models the squared coefficient of variation (CV2) of the normalized expression profiles for each gene,",
    "fitting a trend to account for the mean-variance relationship across genes.\n\n"
  )

  scdrake::plot_hvg_fit(sce, "cv2")
  scdrake::format_used_functions("scran::modelGeneCV2()", do_cat = TRUE)
} else if (hvg_metric == "sctransform") {
  scdrake::catg0("HVGs (n = {cfg$SCT_N_HVG}) were selected by the `sctransform` method.")
}

if (cc_genes_valid && !rlang::is_null(sce_metadata$hvg_rm_cc_genes) && sce_metadata$hvg_rm_cc_genes) {
  scdrake::catg0(
    "Using the percentage of variance explained by the cell cycle phase in the expression profile for each gene, ",
    "we removed {length(sce_metadata$hvg_rm_cc_genes_ids)} genes with percentage > ",
    "{sce_metadata$hvg_cc_genes_var_expl_threshold} prior to HVG selection."
  )
  
  phase_variance_explained <- sce_rowData[sce_rowData$is_cc_related, c("ENSEMBL", "SYMBOL", "phase_variance_explained")] %>%
    as.data.frame() %>%
    dplyr::arrange(-phase_variance_explained) %>%
    scdrake::render_bootstrap_table(row.names = FALSE) %>%
    as.character()

  cat("<details>\n  <summary class='used-functions'>Show cell cycle-related genes \u25be</summary>\n\n")
  cat(phase_variance_explained)
  cat("\n\n</details>")

  p_phase_var_explained <- ggplot2::ggplot(sce_rowData %>% as.data.frame()) +
    ggplot2::geom_histogram(ggplot2::aes(x = phase_variance_explained), binwidth = 0.5) +
    ggplot2::geom_vline(xintercept = sce_metadata$hvg_cc_genes_var_expl_threshold, color = "red") +
    ggplot2::scale_x_continuous(breaks = seq_len(ceiling(max(sce_rowData$phase_variance_explained)))) +
    ggplot2::ggtitle(
      "Histogram of variance explained by cell cycle phase",
      subtitle = stringr::str_wrap("Genes on the right of the red line are marked as cell cycle-related and removed from HVGs.")
    ) +
    ggplot2::theme_bw()
  print(p_phase_var_explained)

  scdrake::format_used_functions("scater::getVarianceExplained()", do_cat = TRUE)
}

if (hvg_metric %in% c("gene_var", "gene_cv2")) {
  scdrake::catg0('\n\nBased on "{hvg_metric}", HVGs were selected by: ')

  if (hvg_selection == "top") {
    scdrake::catg0("top {hvg_selection_value} HVGs.\n\n")
  } else if (hvg_selection == "significance") {
    scdrake::catg0("FDR < {hvg_selection_value}\n\n")
  } else if (hvg_selection == "threshold") {
    scdrake::catg0("variance or CV2 > {hvg_selection_value}\n\n")
  }

  scdrake::catg0("**Found {length(sce_metadata$hvg_ids)} HVGs.**\n\n")
}
```

Variance explained plot:

```{r}
scater::plotExplanatoryVariables(drake::readd(variance_explained, path = drake_cache_dir))
```

Plot of HVGs:

```{r}
drake::readd(hvg_plot, path = drake_cache_dir)
```

***

# Doublet score assignment

The `scran::doubletCluster()` function identifes clusters with expression profiles lying between two other clusters.
Considering every possible triplet of clusters, the method uses the number of DE genes, the median library size,
and the proporion of cells in the cluster to mark clusters as possible doublets.

```{r, results = "asis"}
if (normalization_type_sce == "scran" && "cluster_quickcluster" %in% colnames(sce_colData)) {
  cat("Prior to normalization, quick clustering was performed. We can use those clusters to look at doublet score within them:\n\n")
  boxplot(doublet_score ~ cluster_quickcluster, data = sce_colData)
}
```

```{r, results = "asis"}
if (rlang::is_true(sce_metadata$has_filtered_doublets)) {
  n_doublets <- sum(sce_colData$is_doublet)
  doublets_pct <- (n_doublets / ncol(sce)) * 100
  scdrake::catn(
    glue::glue("**Discarded {n_doublets} cells ({doublets_pct} % of all cells) with doublet score above {sce_metadata$max_doublet_score}**")
  )
} else {
  scdrake::catn(glue::glue("**Cells were not filtered by doublet score.**"))
}
```

`r scdrake::format_used_functions("scDblFinder::computeDoubletDensity()")`

***

# PCA {.tabset}

## PCA plots {.tabset}

### By cell phase

```{r}
patchwork::wrap_plots(drake::readd(pca_phase_plots, path = drake_cache_dir), nrow = 1, guides = "collect")
```

### By doublet score

```{r}
drake::readd(pca_doublet_plot, path = drake_cache_dir)
```

### By total UMI

```{r}
drake::readd(pca_total_plot, path = drake_cache_dir)
```

## PCs selection

- Elbow point method: a simple heuristic for choosing PCs involves identifying the elbow point in the percentage of
  variance explained by successive PCs. This refers to the "elbow" in the curve of a scree plot as shown.
- Technical variance method: use the technical component estimates to determine the proportion of variance that should be retained.
  This is implemented in `scran::denoisePCA()`, which takes the estimates returned by `scran::modelGeneVar()`.
- Forced: use a predefined number of PCs.

```{r}
drake::readd(pca_selected_pcs_plot, path = drake_cache_dir)
```

**`r sce_metadata$pca_selected_pcs` PCs were selected using the "`r sce_metadata$pca_selection_method`" method**

`r scdrake::format_used_functions(c("scater::runPCA()", "PCAtools::findElbowPoint()", "scran::getDenoisedPCs()"))`

***

# Clustering {.tabset}

## Graph-based

Graph-based clustering is commonly used for scRNA-seq, and often shows a good performance.

First, we will use `scran` to generate the shared nearest neighbor graph,
which will then be subjected to community detection using algorithms implemented in the `igraph` package.

Once the SNN graph is generated, we can use any of the community detection algorithms in `igraph` to find the clusters.
Here, we illustrate two of these methods; the walktrap algorithm (*Pons and Latapy 2005*) and the Louvain method (*Blondel et al. 2008*).
We can visualise similarity of both assignments with heatmap and PCA.

```{r}
pheatmap::pheatmap(table(
  drake::readd(cluster_graph_walktrap, path = drake_cache_dir)[[1]],
  drake::readd(cluster_graph_louvain, path = drake_cache_dir)[[1]])
)
```

**Walktrap algorithm: found `r drake::readd(cluster_graph_walktrap_n, path = drake_cache_dir)` clusters.**

```{r, results = "asis"}
scdrake::cells_per_cluster_table_collapsed_html(drake::readd(cluster_graph_walktrap_table, path = drake_cache_dir))
```

**Louvain algorithm: found `r drake::readd(cluster_graph_louvain_n, path = drake_cache_dir)` clusters.**

```{r, results = "asis"}
scdrake::cells_per_cluster_table_collapsed_html(drake::readd(cluster_graph_louvain_table, path = drake_cache_dir))
```

`r scdrake::format_used_functions(c("scran::buildSNNGraph()", "igraph::cluster_walktrap()", "igraph::cluster_louvain()"))`

## k-means

k-means is a generic clustering algorithm that has been used in many application areas.
In R, it can be applied via the `stats::kmeans()` function.
Typically, it is applied to a reduced dimension representation of the expression data
(most often PCA, because of the interpretability of the low-dimensional distances).
We need to define the number of clusters in advance.

### Best K

Determining the number of clusters from the gap statistics and their standard deviations.

```{r}
drake::readd(kmeans_gaps_plot, path = drake_cache_dir)
```

**The best K selected: `r drake::readd(kmeans_best_k, path = drake_cache_dir)`**

```{r, results = "asis"}
scdrake::cells_per_cluster_table_collapsed_html(drake::readd(cluster_kmeans_kbest_table, path = drake_cache_dir))
```

`r scdrake::format_used_functions(c("cluster::clusGap()", "cluster::maxSE()", "stats::kmeans()"))`

### Custom K {.tabset}

- **Custom K (`KMEANS_K`): `r str_comma(cfg$KMEANS_K)`**

```{r, results = "asis"}
for (k in cfg$KMEANS_K) {
  cluster_col <- glue::glue("cluster_kmeans_kc_{k}")
  scdrake::md_header(glue::glue("k = {k}"), 4)
  scdrake::cells_per_cluster_table_collapsed_html(cluster_kmeans_kc_tables[[cluster_col]])
}
```

`r scdrake::format_used_functions("stats::kmeans()")`

## SC3 {.tabset}

Single-Cell Consensus Clustering (`SC3`) is a tool for unsupervised clustering of scRNA-seq data.
SC3 achieves high accuracy and robustness by consistently integrating different clustering solutions through a consensus approach.

*Cluster stability index* shows how stable each cluster is accross the selected range of `k`s.
The stability index varies between 0 and 1, where 1 means that the same cluster appears in every solution for different `k`.

```{r, results = "asis"}
for (k in cfg$SC3_K) {
  cluster_col <- glue::glue("cluster_sc3_{k}")
  scdrake::md_header(glue::glue("k = {k}"), 3)
  scdrake::cells_per_cluster_table_collapsed_html(cluster_sc3_tables[[cluster_col]])
  print(cluster_sc3_stability_plots[[cluster_col]])
}
```

`r scdrake::format_used_functions(c("SC3::sc3()", "SC3::sc3_plot_cluster_stability()"))`

#

***

```{r, child = here::here("Rmd/common/dimred_plots.Rmd")}
```

***

<details>
  <summary class="config">Show input parameters</summary>
  <hr />
  <h4>Main config</h4>

```{r}
print(config_main)
```

  <hr />
  <h4>Normalization and clustering config</h4>

```{r}
print(cfg)
```
  <hr />
</details>

```{r, child = here::here("Rmd/common/_footer.Rmd")}
```
